import { HermesClient } from "@pythnetwork/hermes-client";
import { encodeFunctionData } from "viem";
import { IPythAbi } from "./pyth-abi.mjs";
import { debugTraceCallAction, extractPythPriceFeedsFromDebugTraceCall } from "./tracer/debug-trace-call.mjs";
import { extractPythPriceFeedsFromTraceCallMany, traceCallManyAction } from "./tracer/trace-call-many.mjs";
/**
 * Get the update fee for a given set of update data
 *
 * @param client - The public client instance
 * @param pythContractAddress - The Pyth contract address
 * @param updateData - Array of hex-encoded update data
 * @returns Promise resolving to the update fee in wei
 */ export async function getUpdateFee(client, pythContractAddress, updateData) {
    return await client.readContract({
        address: pythContractAddress,
        abi: IPythAbi,
        functionName: "getUpdateFee",
        args: [
            updateData
        ]
    });
}
/**
 * Fill the Pyth data for a given call request.
 * Requires a client that supports trace_callMany or debug_traceCall with a bundler.
 * This function will trace the call and find all the Pyth price feeds that are needed to fill the call in multiple
 * iterations because a single call might revert if it requires a price feed that is not available and we need to
 * trace the call again with the new price feeds until we have all the price feeds.
 *
 * @param client - The public client instance
 * @param call - The call request to fill with Pyth data
 * @param pythContractAddress - The Pyth contract address
 * @param hermesEndpoint - The Hermes endpoint URL for fetching price updates
 * @param config - Configuration options for tracing and bundling. Default is `{ method: "trace_callMany" }`.
 *   - `Config` with `method: "trace_callMany"`: For trace_callMany method which traces multiple calls separately.
 *     This method traces the Pyth update and original call as separate transactions.
 *   - `Config` with `method: "debug_traceCall"` and `bundler`: For debug_traceCall method with a bundler function to
 *     combine Pyth update with the original call. The bundler creates a single transaction that executes both the
 *     Pyth update and the original call.
 *   - `maxIter`: Maximum number of iterations to find all required price feeds. Each iteration traces the current
 *     transaction(s) to find new Pyth price feed calls. The process stops when no new price feeds are found
 *     or when maxIter is reached. Default is 5.
 * @returns Promise resolving to Pyth update object or undefined if no Pyth data needed
 */ export async function fillPythUpdate(client, call, pythContractAddress, hermesEndpoint, config) {
    config = {
        method: "trace_callMany",
        ...config
    };
    const hermesClient = new HermesClient(hermesEndpoint);
    let requiredPriceFeeds = new Set();
    let pythUpdate;
    for(let i = 0; i < (config.maxIter ?? 5); i++){
        const priceFeeds = await getPriceFeeds(client, pythContractAddress, call, config, pythUpdate);
        if (priceFeeds.isSubsetOf(requiredPriceFeeds)) {
            break;
        } else {
            requiredPriceFeeds = requiredPriceFeeds.union(priceFeeds);
            pythUpdate = await getPythUpdate(client, hermesClient, requiredPriceFeeds, pythContractAddress, call);
        }
    }
    return pythUpdate;
}
const getPythUpdate = async (client, hermesClient, priceFeeds, pythContractAddress, call)=>{
    const hermesResponse = await hermesClient.getLatestPriceUpdates([
        ...priceFeeds
    ]);
    const updateData = hermesResponse.binary.data.map((data)=>`0x${data}`);
    const updateFee = await getUpdateFee(client, pythContractAddress, updateData);
    return {
        call: {
            to: pythContractAddress,
            data: encodeFunctionData({
                abi: IPythAbi,
                functionName: "updatePriceFeeds",
                args: [
                    updateData
                ]
            }),
            from: call.from,
            value: updateFee
        },
        updateData,
        updateFee
    };
};
/**
 * Get the price feeds from the trace of the given call.
 */ const getPriceFeeds = async (client, pythContractAddress, call, config, pythUpdate)=>{
    switch(config.method){
        case "debug_traceCall":
            {
                return extractPythPriceFeedsFromDebugTraceCall(await client.extend(debugTraceCallAction).debugTraceCall(pythUpdate ? config.bundler(pythUpdate, call) : call), pythContractAddress);
            }
        case "trace_callMany":
            {
                return extractPythPriceFeedsFromTraceCallMany(await client.extend(traceCallManyAction).traceCallMany(pythUpdate ? [
                    pythUpdate.call,
                    call
                ] : [
                    call
                ]), pythContractAddress);
            }
    }
};

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get extractPythPriceFeedsFromTraceCallMany () {
        return extractPythPriceFeedsFromTraceCallMany;
    },
    get traceCallManyAction () {
        return traceCallManyAction;
    }
});
const _viem = require("viem");
const _pythabi = require("../pyth-abi.cjs");
function extractPythPriceFeedsFromTraceCallMany(traceResults, pythContractAddress, ignoreParsingErrors = false) {
    const result = new Set();
    for (const traceResult of traceResults){
        for (const trace of traceResult.trace){
            if ((0, _viem.isAddressEqual)(trace.action.to, pythContractAddress)) {
                // Decode the calldata to see what function is being called
                try {
                    const decoded = (0, _viem.decodeFunctionData)({
                        abi: _pythabi.IPythAbi,
                        data: trace.action.input
                    });
                    let priceFeedId;
                    switch(decoded.functionName){
                        case "getPrice":
                        case "getPriceNoOlderThan":
                        case "getPriceUnsafe":
                        case "getEmaPrice":
                        case "getEmaPriceNoOlderThan":
                        case "getEmaPriceUnsafe":
                            {
                                priceFeedId = decoded.args[0];
                                break;
                            }
                        default:
                            {
                                break;
                            }
                    }
                    if (priceFeedId !== undefined) {
                        result.add(priceFeedId);
                    }
                } catch  {
                    if (!ignoreParsingErrors) {
                        throw new Error(`Failed to decode calldata: ${trace.action.input}. Make sure correct Pyth contract address is used.`);
                    }
                }
            }
        }
    }
    return result;
}
const traceCallManyAction = (client)=>({
        async traceCallMany (args) {
            return client.request({
                method: "trace_callMany",
                params: [
                    args.map((a)=>[
                            (0, _viem.formatTransactionRequest)(a),
                            [
                                "trace"
                            ]
                        ]),
                    "latest"
                ]
            });
        }
    });

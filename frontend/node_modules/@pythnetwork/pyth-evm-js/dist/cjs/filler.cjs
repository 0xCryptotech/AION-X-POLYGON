"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get fillPythUpdate () {
        return fillPythUpdate;
    },
    get getUpdateFee () {
        return getUpdateFee;
    }
});
const _hermesclient = require("@pythnetwork/hermes-client");
const _viem = require("viem");
const _pythabi = require("./pyth-abi.cjs");
const _debugtracecall = require("./tracer/debug-trace-call.cjs");
const _tracecallmany = require("./tracer/trace-call-many.cjs");
async function getUpdateFee(client, pythContractAddress, updateData) {
    return await client.readContract({
        address: pythContractAddress,
        abi: _pythabi.IPythAbi,
        functionName: "getUpdateFee",
        args: [
            updateData
        ]
    });
}
async function fillPythUpdate(client, call, pythContractAddress, hermesEndpoint, config) {
    config = {
        method: "trace_callMany",
        ...config
    };
    const hermesClient = new _hermesclient.HermesClient(hermesEndpoint);
    let requiredPriceFeeds = new Set();
    let pythUpdate;
    for(let i = 0; i < (config.maxIter ?? 5); i++){
        const priceFeeds = await getPriceFeeds(client, pythContractAddress, call, config, pythUpdate);
        if (priceFeeds.isSubsetOf(requiredPriceFeeds)) {
            break;
        } else {
            requiredPriceFeeds = requiredPriceFeeds.union(priceFeeds);
            pythUpdate = await getPythUpdate(client, hermesClient, requiredPriceFeeds, pythContractAddress, call);
        }
    }
    return pythUpdate;
}
const getPythUpdate = async (client, hermesClient, priceFeeds, pythContractAddress, call)=>{
    const hermesResponse = await hermesClient.getLatestPriceUpdates([
        ...priceFeeds
    ]);
    const updateData = hermesResponse.binary.data.map((data)=>`0x${data}`);
    const updateFee = await getUpdateFee(client, pythContractAddress, updateData);
    return {
        call: {
            to: pythContractAddress,
            data: (0, _viem.encodeFunctionData)({
                abi: _pythabi.IPythAbi,
                functionName: "updatePriceFeeds",
                args: [
                    updateData
                ]
            }),
            from: call.from,
            value: updateFee
        },
        updateData,
        updateFee
    };
};
/**
 * Get the price feeds from the trace of the given call.
 */ const getPriceFeeds = async (client, pythContractAddress, call, config, pythUpdate)=>{
    switch(config.method){
        case "debug_traceCall":
            {
                return (0, _debugtracecall.extractPythPriceFeedsFromDebugTraceCall)(await client.extend(_debugtracecall.debugTraceCallAction).debugTraceCall(pythUpdate ? config.bundler(pythUpdate, call) : call), pythContractAddress);
            }
        case "trace_callMany":
            {
                return (0, _tracecallmany.extractPythPriceFeedsFromTraceCallMany)(await client.extend(_tracecallmany.traceCallManyAction).traceCallMany(pythUpdate ? [
                    pythUpdate.call,
                    call
                ] : [
                    call
                ]), pythContractAddress);
            }
    }
};
